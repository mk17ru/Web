package ru.itmo.wp.model.repository.impl;

import ru.itmo.wp.model.database.DatabaseUtils;
import ru.itmo.wp.model.domain.Event;
import ru.itmo.wp.model.domain.Talk;
import ru.itmo.wp.model.exception.RepositoryException;

import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public abstract class BasicRepositoryImpl<T> {
    protected final DataSource DATA_SOURCE = DatabaseUtils.getDataSource();

    protected PreparedStatement connectionImpl(Integer returnGeneratedKeys, String text) throws SQLException {
        Connection connection = DATA_SOURCE.getConnection();
        if (returnGeneratedKeys != null) {
            return connection.prepareStatement(text, returnGeneratedKeys);
        } else {
            return connection.prepareStatement(text);
        }
    }

    protected T findBy(List<Object> id, String text) {
        try {
            PreparedStatement statement = connectionImpl(null, text);
            applyStatement(statement, id);
            try (ResultSet resultSet = statement.executeQuery()) {
                return toObject(statement.getMetaData(), resultSet);
            }
        } catch (SQLException e) {
            throw new RepositoryException("Can't find.", e);
        }
    }

    public List<T> findAll(String text, List<Object> l) {
        List<T> objs = new ArrayList<>();
        try {
            PreparedStatement statement = connectionImpl(null, text);
            applyStatement(statement, l);
            try (ResultSet resultSet = statement.executeQuery()) {
                T obj;
                while ((obj = toObject(statement.getMetaData(), resultSet)) != null) {
                    objs.add(obj);
                }
            }
        } catch (SQLException e) {
            throw new RepositoryException("Can't find.", e);
        }
        return objs;
    }

    public List<T> findAllBy(long id, String param) {
        return  findAll("SELECT * FROM " + getName() + " WHERE " + param + " ORDER BY creationTime DESC", Arrays.asList(id, id));
    }

    protected abstract void generatedKeys(ResultSet generatedKeys, T object) throws SQLException;

    protected abstract void setStatementKeys(PreparedStatement statement, T object, List<Object> l) throws SQLException;

    protected abstract T toObject(ResultSetMetaData metaData, ResultSet resultSet) throws SQLException;

    protected abstract String getName();

    protected T find(long id) {
        return findBy(Collections.singletonList(id), "SELECT * FROM " + getName() + " WHERE id=?");
    }

    public void save(T object, String text, List<Object> l) {
        try {
            PreparedStatement statement = connectionImpl(Statement.RETURN_GENERATED_KEYS, text);
            setStatementKeys(statement, object, l);
            if (statement.executeUpdate() != 1) {
                throw new RepositoryException("Can't save.");
            } else {
                ResultSet generatedKeys = statement.getGeneratedKeys();
                if (generatedKeys.next()) {
                    generatedKeys(generatedKeys, object);
                } else {
                    throw new RepositoryException("Can't save [no autogenerated fields].");
                }
            }
        } catch (SQLException e) {
            throw new RepositoryException("Can't save.", e);
        }
    }

    protected void applyStatement(PreparedStatement statement, List<Object> l) throws SQLException {
        if (l == null) {
            return;
        }
        for (int i = 0; i < l.size(); ++i) {
            Object o = l.get(i);
            if (o instanceof String) {
                statement.setString(i + 1, (String)o);
            } else if (o instanceof Long) {
                statement.setLong(i + 1, (Long)o);
            }
        }
    }
}